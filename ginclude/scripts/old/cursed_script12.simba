program deezNuts;

{$DEFINE SMART}              // Always have this to load smart
{$I SRL-6/SRL.simba}         // To load the SRL include files
{$I SPS/lib/SPS-RS3.Simba}   // To load the SPS include files

var
  failtimer, failtimer2, waitTimer, energyTimer, mainloopTimer, reloadTimer: TTimeMarker;
  i, x, y, presetCounter, prevXP, totalBreakTime, noGreen, freedomSlot, wealthSlot, minsToRunFor2, reloadTime,
  monkfishDTM, closeDTM, rowDTM, freedomDTM, unpinDTM, flagDTM:  integer;
  cursedWispRift, cursedWispLocation, gotovarrockwest,
  lodeToWisp1, lodeToWisp2: TSPSArea;
  cursedWispTPA, cursedWispTPA1, cursedWispTPA2, riftTPA, siphonTPA, mmTPA, msTPA: TPointArray;
  playerBox, playerBox1, riftBox, siphonBoundsBox, wildyLevelBox, aBox, minimap1, minimap2: TBox;
  cursedWispATPA, riftATPA, siphonATPA, msATPA1: T2DPointArray;
  riftOption, riftText, wispText:  TStringArray;
  p, q, r, s, t: TPoint;
  weTeleported, weShouldTeleport, weLoaded, justClick, weShouldTakeASecondPic,
  alreadySetup, firstLoad: boolean;

{$I ginclude/master.simba}

const
  language = 'english';

/////////////////////////////Everybody User Input BEGIN/////////////////////////
  name1 = 'ultraballer777@gmail.com';
  pass1 = 'madcowdisease12';
  world1 = 117;
  freedomSlotInput = 2;
  youAreRay = false; //SET TO TRUE IF YOU'RE RAY

  ChargesPerROW = 2;
  ChanceToBigWalk = 100;

  weShouldExitToLobbyOnTerminate = true; //more humanlike to logout after error
  weShouldKillClientOnTerminate = true; //so that you can usually tell if script crashed just via VM's cpu usage
/////////////////////////////MOO User Input BEGIN///////////////////////////////
  isVPS = false; //Doesn't matter if you're ray
  openBackpackOnLoginProcedure = false;

  minRiftLength = 5000;
  noGreenMax = 5;
  wealthSlotInput = 10;  //doesn't matter currently
/////////////////////////////User Input END/////////////////////////////////////

  {out of 100}
  chanceOfMinibreaksInbetweenSiphons = 80;
  chanceOfBreaksInbetweenSiphons = 1;
  chanceOfBreaksBeforeDepositing = 2;
  chanceOfMinibreaksAfterDepositing = 50;
  chanceOfBreaksAfterDepositing = 2;

  siphonColor = 13665320;
  siphonTol   = 25;
  siphonHue   = 0.07;
  siphonSat   = 0.75;

procedure declarePlayers();
begin
  setLength(players, 1);
  with players[0] do
  begin
    loginName := name1;
    password := pass1;
    isActive := true;
    isMember := true;
    world := world1;
  end;
  currentPlayer := 0;
end;

//waits a bit after loading client, to compensate for lagg.
function smartCreateClient(w, h: integer): boolean; override;
var
  plugins: string;
  params: TStringArray;
  path: string;
  wePaired: boolean;
begin
  print('smartCreateClient():', TDebug.HEADER);

  if (not smartGetParameters(params)) then
  begin
    print('Failed to grab parameters', TDebug.FOOTER);
    exit(false);
  end;

  path := getJavaPath();
  plugins := implode(',', smartPlugins);

  print('Root: ' + params[0]);
  print('Params: ' + params[1]);
  print('Using plugins "' + plugins + '"');

  __smartCurrentTarget := 0;
  __smartCurrentTarget := smartSpawnClient(path, stringReplace(PluginPath, '\', '/', [rfReplaceAll]),
                                           params[0], params[1], w, h, smartInitSeq, smartUserAgent,'', plugins);

  writeln('__smartCurrentTarget is: ', __smartCurrentTarget);
  if (__smartCurrentTarget = 0) then
  begin
    writeln('waiting for 15k');
    wait(15000);
    writeln('done waiting for 15k');
    if smartPairToExistingClient then
      wePaired := true;
  end;

  if (__smartCurrentTarget <> 0) then
  begin
    print('Succesfully spawned a client, attempting to target');

    //access violation?
    if wePaired then
      wePaired := false else
      __smartCurrentPID := smartGetClientPID(__smartCurrentTarget);

    if (smartSetAsTarget(__smartCurrentPID)) then
    begin
      print('smartCreateClient(): result = true', TDebug.FOOTER);
      result := true;
    end;
  end else
    print('Failed to spawn a SMART client', TDebug.FOOTER);
end;

function getPixelShift9(b: TBoxArray; time: integer): TIntegerArray;
var
  l, i: integer;
  bmpBefore, bmpAfter: TIntegerArray;
begin
  l := length(b);
  setLength(bmpBefore, l);
  setLength(bmpAfter, l);
  setLength(result, l);

  // get the initial pixels
  for i := 0 to (l - 1) do
    bmpBefore[i] := bitmapFromClient(b[i].x1, b[i].y1, b[i].x2, b[i].y2);

  wait(time);

  // get pixels after the wait
  for i := 0 to (l - 1) do
    bmpAfter[i] := bitmapFromClient(b[i].x1, b[i].y1, b[i].x2, b[i].y2);

  // calculate the pixels that changed
  for i := 0 to (l - 1) do
    result[i] := calculatePixelShift(bmpBefore[i], bmpAfter[i], intToBox(0, 0, (b[i].x2 - b[i].x1), (b[i].y2 - b[i].y1)));

  freeBitmaps(bmpBefore);
  freeBitmaps(bmpAfter);
end;

function getPixelShift9(b: TBox; time: integer): integer; overload;
var
  arr: TIntegerArray;
begin
  arr := getPixelShift9([b], time);
  result := arr[0];
end;

function TRSMinimap.isPlayerMoving9(shiftInterval: integer = 500): boolean;
var
  shiftBox: TBox;
  c: TPoint;
begin
  c := self.getCenterPoint();
  shiftBox.setBounds(c.x - 30, c.y - 30, c.x + 30, c.y + 30);
  result := (getPixelShift9(shiftBox, shiftInterval) > 200);
end;

function TRSMinimap.waitPlayerMoving9(shiftInterval: integer = 500; maxTime: integer = 20000): boolean;
var
  t: LongWord;
begin
  result := false;
  t := (getSystemTime() + maxTime);

  print('Waiting while the player is moving...', TDebug.SUB);

  while (getSystemTime() < t) do
  begin
    wait(randomRange(50, 100));
    if (not self.isPlayerMoving9(shiftInterval)) then
      exit(true);
  end;
end;

function getPixelShift(b: TBoxArray; time: integer): TIntegerArray; override;
var
  l, i: integer;
  bmpBefore, bmpAfter: TIntegerArray;
begin
  l := length(b);
  setLength(bmpBefore, l);
  setLength(bmpAfter, l);
  setLength(result, l);

  // get the initial pixels
  for i := 0 to (l - 1) do
    bmpBefore[i] := bitmapFromClient(b[i].x1, b[i].y1, b[i].x2, b[i].y2);

  failtimer.start;
  repeat
    wait(gaussRangeInt(150, 300));
    teleCheck;
    if weTeleported then
    begin
      writeln('we just teleported, exitting getPixelShift');
      exit([0]);
    end;
  until (failtimer.getTime > time);


  // get pixels after the wait
  for i := 0 to (l - 1) do
    bmpAfter[i] := bitmapFromClient(b[i].x1, b[i].y1, b[i].x2, b[i].y2);

  // calculate the pixels that changed
  for i := 0 to (l - 1) do
    result[i] := calculatePixelShift(bmpBefore[i], bmpAfter[i], intToBox(0, 0, (b[i].x2 - b[i].x1), (b[i].y2 - b[i].y1)));

  freeBitmaps(bmpBefore);
  freeBitmaps(bmpAfter);
end;

function getPixelShift(b: TBox; time: integer): integer; override;
var
  arr: TIntegerArray;
begin
  arr := getPixelShift([b], time);
  result := arr[0];
  writeln('asdf');
end;

function TRSChooseOption.__find(): boolean; override;
const
  BORDER_COLORS = [197636, 3618615, 3748386];
  CORNER_COLOR = 2368548;
var
  tpa, tpaBorder: TPointArray;
  atpaBorder: T2DPointArray;
  i, len: integer;
  bounds: TBox;
begin
  result := false;

  freeze();

  for i := 0 to high(BORDER_COLORS) do
    if (findColors(tpa, BORDER_COLORS[i], getClientBounds())) then
      appendTPA(tpaBorder, tpa);

  unfreeze();

  if (length(tpaBorder) < 1) then
    exit();

  atpaBorder := clusterTPAEx(tpaBorder, 2, 2);
  sortATPASize(atpaBorder, true);
  len := length(atpaBorder);

  for i := 0 to (len - 1) do
  begin
    bounds := getTPABounds(atpaBorder[i]);

    if (distance(bounds.x1, bounds.y1, bounds.x2, bounds.y2) < 100) then
      continue();

    if (getColor(bounds.x1, bounds.y1 - 1) = CORNER_COLOR) then
    begin
      self.setBounds([bounds.x1 + 1, bounds.y1 + 1, bounds.x2 - 1, bounds.y2 - 1]); // decrease size to remove borders
      writeln('chooseoption bounds is: ', self.getbounds);
      exit(true);
    end;
  end;
end;

function TRSMinimap.waitFlag1(dist: integer = 0): boolean;
var
  m, t : LongWord;
  d1, d2: integer;
  p, c: TPoint;
begin
  result := false;
  m := getSystemTime();
  t := (m + 20000);

  repeat
    if (not self.isFlagPresent(p)) then
    begin
      result := true;
      break;
    end;

    c := self.getCenterPoint();
    d1 := distance(p.x, p.y, c.x, c.y);

    if (d1 <= dist) then
    begin
      result := true;
      break;
    end;

    teleCheck;
    if weTeleported then
      exit;

    if (d1 > (dist + 12)) then
      wait(450 + random(70))
    else
      wait(50 + random(50));

    if (getColor(6, 56) <> 13092807) then // border of the loading message
      if (getSystemTime() - m > 5000) then
      begin
        if (d1 = d2) then
          break();


        d2 := d1;
        m := getSystemTime();
      end;

    {
    if (SRL_Events[EVENT_ANTIBAN] <> nil) then
      SRL_Events[EVENT_ANTIBAN]();
    }

  until (getSystemTime() > t);
end;

function TSPSArea.getPlayerPos1(tolerance: integer = 300; accuracy: extended = 0.4): TPoint;
var
  foundMatches, wid, hei, t: integer;
  bmp: TMufasaBitmap;
  map: T3DIntegerArray;
  p: TPoint;
  searches, a: extended;
begin
  result := [-1, -1];

  if (not isLoggedIn()) then
    exit();

  if (not self.isSetup) then
  begin
    print('Unable to get players postion, sps isn''t setup', TDebug.ERROR);
    exit();
  end;

  t := getSystemTime();
  a := minimap.getAngleDegrees();

  if (inRange(a, 10.0, 350.0)) and (not spsAnyAngle) then
  begin
    print(self.getName()+'.getPlayerPos1(): Angle is at '+floatToStr(a)+', Setting angle to 0 degrees');
    minimap.clickCompass();
  //  mainScreen.setAngle(MS_ANGLE_HIGH);
  end;

  bmp := SPS_GatherMinimap(spsAnyAngle, a);

  wid := bmp.getWidth();
  hei := bmp.getHeight();

  SPS_BitmapToMap(bmp, self._accuracy, map);

  if (length(map) > 0) then
  begin
    foundMatches := SPS_FindMapInMap(p.x, p.y, self.__areaMap, map, tolerance);
    searches := ((wid / self._accuracy) * (hei / self._accuracy));

    if ((foundMatches / searches) > accuracy) then
    begin
      result.x := (p.x * self._accuracy + (wid div 2));
      result.y := (p.y * self._accuracy + (wid div 2));
    end else
      print(self.getName()+'.getPlayerPos1(): Didn''t find enough matches accurately calc your postion', TDebug.WARNING);
  end;

  bmp.free();

  print(self.getName()+'.getPlayerPos1(): result = ' + toStr(result) + ', took ' + intToStr(getSystemTime() - t) + ' ms');
end;

function TSPSArea.walkPath1(path: TPointArray; waitMoving: Boolean = False; shiftInterval: Integer = 500): boolean;
var
  p, lastPos, mmPoint: TPoint;
  t, fails, h, l, i: integer;
begin
  result := false;;

  h := high(path);
  l := low(path);

  t := (getSystemTime() + randomRange(15000, 20000));

  repeat
    if (not isLoggedIn()) then
      exit(false);

    p := self.getPlayerPos1();

    for i := h downto l do
      if (SPS_PosToMM(path[i], p, mmPoint)) then
      begin
        if (distance(minimap.getCenterPoint(), mmPoint) >= 10) then
        begin
          if (spsMultiMouse) then
            multiClick(mmPoint, 25, 3)
          else
            mouse(mmPoint, MOUSE_LEFT);

          if (minimap.isFlagPresent(2500 + random(500))) then
            minimap.waitFlag1(10 + random(25));
        end;

        t := (getSystemTime() + randomRange(15000, 20000));

        result := (i = h) or (distance(path[i], path[h]) < 10);

        if (result) then
          break(2)
        else
          break();

      end;

    if (p.x = lastPos.x) and (p.y = lastPos.y) then
      inc(fails);

    lastPos := p;

  until (getSystemTime() > t) or (fails > 5);

  if waitMoving then
    if (minimap.isFlagPresent() or minimap.isPlayerMoving()) then
      minimap.waitPlayerMoving(shiftInterval);

  print(self.getName()+'.walkPath(): result = '+boolToStr(result));
end;

function TSPSArea.walkPath2(path: TPointArray; waitMoving: Boolean = False; shiftInterval: Integer = 500): boolean;
var
  p, lastPos, mmPoint: TPoint;
  t, fails, h, l, i: integer;
begin
  result := false;;

  h := high(path);
  l := low(path);

  t := (getSystemTime() + randomRange(15000, 20000));

  repeat
    if (not isLoggedIn()) then
      exit(false);

    p := self.getPlayerPos1();

    for i := h downto l do
      if (SPS_PosToMM(path[i], p, mmPoint)) then
      begin
        if (distance(minimap.getCenterPoint(), mmPoint) >= 10) then
        begin
          if (spsMultiMouse) then
            multiClick(mmPoint, 25, 3)
          else
            mouse(mmPoint, MOUSE_LEFT);

          if (minimap.isFlagPresent(2500 + random(500))) then
            minimap.waitFlag(10 + random(25));
        end;

        t := (getSystemTime() + randomRange(15000, 20000));

        result := (i = h) or (distance(path[i], path[h]) < 10);

        if (result) then
          break(2)
        else
          break();

      end;

    if (p.x = lastPos.x) and (p.y = lastPos.y) then
      inc(fails);

    lastPos := p;

  until (getSystemTime() > t) or (fails > 5);

  if waitMoving then
    if (minimap.isFlagPresent() or minimap.isPlayerMoving()) then
      minimap.waitPlayerMoving(shiftInterval);

  print(self.getName()+'.walkPath(): result = '+boolToStr(result));
end;

function TSPSArea.blindWalk1(pos: TPoint): boolean;
var
  tries: integer;
  ctrlPoints: TPointArray;
  p: TPoint;
begin
  result := false;

  repeat
    if (not isLoggedIn()) then
      exit();

    p := self.getPlayerPos1();

    inc(tries);

    if ((tries) > 10) then
      break();
  until (not p.equals([-1, -1]));

  if (tries <= 10) then
  begin
    ctrlPoints := TPABetweenPoints(p, pos, 15 + random(25), 15);
    result := self.walkPath1(ctrlPoints);
  end;

  print(self.getName()+'.blindWalk1(): result = '+boolToStr(result));
end;

function TSPSArea.blindWalk2(pos: TPoint): boolean;
var
  tries: integer;
  ctrlPoints: TPointArray;
  p: TPoint;
begin
  result := false;

  repeat
    if (not isLoggedIn()) then
      exit();

    p := self.getPlayerPos1();

    inc(tries);

    if ((tries) > 10) then
      break();
  until (not p.equals([-1, -1]));

  if (tries <= 10) then
  begin
    ctrlPoints := TPABetweenPoints(p, pos, 15 + random(25), 15);
    result := self.walkPath2(ctrlPoints);
  end;

  print(self.getName()+'.blindWalk1(): result = '+boolToStr(result));
end;

procedure terminator();
begin
  writeln('Ayyy we terminating, screenshot writing to C:\Simba\debug.png');
  saveScreenshot('C:\Simba\debug.png');
  //PlaySound('C:\Users\R1\Downloads\custom2slayertaskdone');

  if weLoaded then
  begin
    FreeDTM(monkfishDTM);
    FreeDTM(closeDTM);
    FreeDTM(rowDTM);
    FreeDTM(freedomDTM);
    FreeDTM(unpinDTM);
  end;

  if weShouldTeleport then
  begin
    teleAway;
    wait(gaussrangeint(10500, 13500));
  end;
  if weShouldExitToLobbyOnTerminate then
    players[0].exitToLobby;
  if weShouldKillClientOnTerminate then
  begin
    smartFreeCurrentClient();
    smartKillClient(__smartCurrentPID);
  end;
end;

procedure loginProcedure();
begin
  if not isLoggedIn() then
  begin             // If player isn't logged in then
    players[currentPlayer].login();    // Log them in
    waitForCompass;
  end;

  if ((minimap.getAngleDegrees > 5) and (minimap.getAngleDegrees < 355)) then
    begin
      writeLn('Setting Compass');
      minimap.clickCompass;
      mainScreen.setAngle(MS_ANGLE_HIGH);
      wait(randomrange(650, 1250));

      if gameTabs.isTabActive(TAB_TASK) then
        if findDTM(unpinDTM, x, y, tabBackpack.getBounds) then
        begin
          writeln('unpinDTM is: ', x, y);
          writeln('clicking unpinDTM');
          mouse(point(x, y), mouse_left);
          wait(gaussRangeInt(400, 750));
        end;

      if openBackpackOnLoginProcedure then
        tabBackpack.open;
      exitTreasure;
      closePopup;
      gameTabs.openTab(TAB_EQUIPMENT);
    end;
end;

procedure setupLanguage();
begin
  Case language Of
    //english
    'english':
    begin
      riftOption    := ['to ene'];
      wispText      := ['arves', 'ronic'];   //instead of 'wisp'
      riftText      := ['Conv'];
    end;
    //german
    'german':
    begin
      riftOption    := ['In En'];
      wispText      := ['Verf'];
      riftText      := ['Erinn'];
    end;
    //portugal
    'portugal':
    begin
      riftOption    := ['ia Fi'];
      wispText      := ['Fogo'];
      riftText      := ['Fiss'];
    end;
    //french
    'french':
    begin
      riftOption    := ['ie Fa'];
      wispText      := ['Sph'];
      riftText      := ['Conv'];
    end;
  end;
  writeln('Selected language: ', language, ' ******Uptext As Follows*******',riftOption, wispText, riftText);
end;

procedure setupVariables();
begin
  weLoaded := true;
  firstLoad := true;
  cursedWispRift.setup('cursedWispRift', RUNESCAPE_SURFACE);

  lodeToWisp1.setup('lodeToWisp1', RUNESCAPE_SURFACE);
  lodeToWisp2.setup('lodeToWisp2', RUNESCAPE_SURFACE);

  gotovarrockwest.setup('gotovarrockwest', RUNESCAPE_SURFACE);

  //cursedWispLocation.setup('cursedWispLocation', RUNESCAPE_SURFACE);
  setupLanguage();
  searchBox1.setBounds(35, 532, 93, 547);
  wildyLevelBox.setBounds(505, 26, 573, 45);
  playerBox.setBounds(206, 120, 360, 270);
  playerBox1.setBounds(266, 169, 306, 215);
  minimap1.setBounds(620, 18, 752, 193);
  minimap2.setBounds(582, 58, 794, 158);

  freedomSlot := freedomSlotInput;
  wealthSlot := wealthSlotInput;

  monkfishDTM := DTMFromString('mbQAAAHicY2VgYAhnYmDwBeIYIE4H4jQgDmVkYAgE4jggjgRifyD2c7MBqmZCwZJAkhENs2ARAwMAcb0Eiw==');
  closeDTM := DTMFromString('mbQAAAHicY2VgYFBjgmAFKK0LxOJAcQEGCC0LpT9s1GDYJMXM0MfLxNDAwgCm+YHi6JgJCwYDAHyGBew=');
  rowDTM := DTMFromString('mWAAAAHicY2FgYHjLxMBwD4jvM0HYAkDMBqVZgTiAMxuoigmOJRlQAUiUEQmDAABUbAS/');
  freedomDTM := DTMFromString('mggAAAHicY2NgYJjByMAwAYhbgXgqEM8E4oVA/AMo9xyIvwExM5D/Gki/AWJbO1uGqGmScCwuIQGmJYFy2DATDgwBAMDFDf4=');
  unpinDTM := DTMFromString('mggAAAHicY2NgYOBjZmDgB2IuZghbBIg5gTiYkYHBF4gDgTgciEOg/LsbpRjmBAUzFOkYMjhxczN48vAwLFm2kkESaBY2zIQDQwAArroJYA==');
  flagDTM := DTMFromString('mLgAAAHicY2JgYLBgZGAwAeImILsDiG+qQrAkAwQzQjEDAwBlegOr');

  totalBreakTime := 0;
end;

procedure setup();
begin
  clearDebug();               // Clear the debug box
  smartEnableDrawing := true; // So we can draw on SMART
  declarePlayers();             // Set up your username/pass
  smartShowConsole := false;        //
  disableIPScreenshots := true;
  disableSRLLog := true;
  addOnTerminate('terminator');
  setupSRL();                   // Load the SRL include files
  setupVariables();
  loginProcedure();
end;

procedure wildyBreakTime(miniBreak: boolean);
var
  howLongToBreakFor: integer;
  wildyBreakTimer: TTimeMarker;
  weLogging: boolean;
begin
  if weTeleported then
    exit;

  if minibreak then
  case RandomRange(1, 1000) of
    1..100: howLongToBreakFor := gaussRangeInt(1, 601);
    101..200: howLongToBreakFor := gaussRangeInt(1, 601);
    201..300: howLongToBreakFor := gaussRangeInt(601, 1201);
    301..400: howLongToBreakFor := gaussRangeInt(1201, 2401);
    401..500: howLongToBreakFor := gaussRangeInt(1201, 2401);
    501..600: howLongToBreakFor := gaussRangeInt(1801, 2401);
    601..700: howLongToBreakFor := gaussRangeInt(2401, 3001);
    701..800: howLongToBreakFor := gaussRangeInt(3001, 4201);
    801..900: howLongToBreakFor := gaussRangeInt(4201, 9001);
    901..1000: howLongToBreakFor := gaussRangeInt(9001, 15001);
  end else  //3.2 second wait on average?
  case RandomRange(1, 1000) of
    1..100: howLongToBreakFor := gaussRangeInt(100, 60100);
    101..200: howLongToBreakFor := gaussRangeInt(100, 60100);
    201..300: howLongToBreakFor := gaussRangeInt(60100, 120100);
    301..400: howLongToBreakFor := gaussRangeInt(120100, 240100);
    401..500: howLongToBreakFor := gaussRangeInt(120100, 240100);
    501..600: howLongToBreakFor := gaussRangeInt(180100, 240100);
    601..700: howLongToBreakFor := gaussRangeInt(240100, 300100);
    701..800: howLongToBreakFor := gaussRangeInt(300100, 420100);
    801..900: howLongToBreakFor := gaussRangeInt(420100, 900100);
    901..1000: howLongToBreakFor := gaussRangeInt(900100, 1500100);
  end;      //5.4 minute wait on average?

  weLogging := false;
  if ((howLongToBreakFor > gaussRangeInt(9500, 18500)) or (not miniBreak)) then
    weLogging := true;

  wildyBreakTimer.start;
  smartImage.clear;

  totalBreakTime := totalBreakTime + howLongToBreakFor;

  if weLogging then
  begin
    players[currentPlayer].exitToLobby();
    writeln('weLogging is: ', weLogging, ' and we are going to be waiting for ', howLongToBreakFor/1000, ' seconds');
    wait(howLongToBreakFor + 1);
    loginProcedure;
  end else
    writeln('weLogging is: ', weLogging, ' and we are going to be waiting for ', howLongToBreakFor/1000, ' seconds');

  repeat
    teleCheck;
    if weTeleported then
      break;
    wait(gaussRangeInt(50, 200));
  until (wildyBreakTimer.getTime > howLongToBreakFor);
end;

//**********************************************************
// - finds wisp colours and puts it into tpa
// - converts the tpa into atpa and filters points to closest aswell as ones too small
//**********************************************************
function findWisp(): boolean;
begin
  loginProcedure;

  if conversationBox.isOpen then
  begin
    failtimer.start;
    repeat //just incase im not properly understanding the code that I didn't look through
      if RandomRange(1, 100) < 50 then
        conversationBox.continue(true, true, true) else
        conversationBox.continue(false, true, true);
    until ((failtimer.getTime > gaussRangeInt(15000, 20000)) or (not conversationBox.isOpen));
    if failtimer.getTime > 15000 then
      scriptTerminator('failed to clear conversation box in 15-20 seconds');
  end;

  if (not findColorsTolerance(cursedWispTPA1, 6460618, mainScreen.getBounds, 14, ColorSetting(2, 0.26, 1.9)) and (not findColorsTolerance(cursedWispTPA2, 11887459, mainScreen.getBounds, 10, colorSetting(2, 0.62, 2.52)))) then
  begin
    writeln('Could not find wisps, returning false and exiting');
    exit(false);
  end;

  writeln('Found Wisps');
  if ((length(cursedWispTPA1) > 0) and (length(cursedWispTPA2) > 0)) then
  begin
    writeln('merger time');
    cursedWispTPA1.combine(cursedWispTPA2);
    cursedWispTPA := cursedWispTPA1.copy;
  end else
  begin
    writeln('not merger time');
    if length(cursedWispTPA1) > 0 then
      cursedWispTPA := cursedWispTPA1.copy else
      cursedWispTPA := cursedWispTPA2.copy;
  end;

  writeln('turning cursedWispTPA into an ATPA');
  cursedWispATPA := cursedWispTPA.toATPA(20, 20);      //converts the wisps in TPA to ATPA
  cursedWispATPA.filterBetween(0, 10);           //filter points too small to be wisps
  if length(cursedWispATPA) < 1 then
    exit(false);

  writeln('filtering out player & wildyLevel Boxes from ATPA results');
  for i := high(cursedWispATPA) downto 0 do
  begin
    if playerBox.overlap(cursedWispATPA[i].getBounds) then
    begin
      cursedWispATPA.deleteIndex(i);
      continue;
    end;
    if wildyLevelBox.overlap(cursedWispATPA[i].getBounds) then
      cursedWispATPA.deleteIndex(i);
  end;
  writeln('done filtering out player & wildyLevel Boxes from ATPA results');

  if length(cursedWispATPA) > 0 then         //checks if ATPA is presen
    cursedWispATPA.sortFromMidPoint(mainscreen.playerPoint) else         //sorts to closest to player
    exit(false);

  writeln('cursedWispATPA is: ', cursedWispATPA);
  smartImage.debugATPA(cursedWispATPA);

  if length(cursedWispATPA) > 20 then
  begin
    writeln('why is there more than 20 wisps on MS?? exitting false');
    exit(false);
  end;

  exit(true);
end;

function findNearestSiphon(): boolean;
begin
  minimap.waitPlayerMoving;

  if not findColorsTolerance(siphonTPA, siphonColor, playerBox, siphonTol, colorSetting(2, siphonHue, siphonSat)) then
    exit(false);

  siphonATPA := siphonTPA.toATPA(35);
  siphonATPA.filterBetween(0, 100);
  siphonATPA.sortBySize(true);

  for i := high(siphonATPA) downto 0 do
  begin
    if playerBox1.isPointInside(siphonATPA[i].getBounds.getMiddle) then
      siphonATPA.deleteIndex(i);
  end;

  writeln('test');
  if length(siphonATPA) < 1 then
    exit(false);

  smartImage.DebugATPA(siphonATPA);

  siphonBoundsBox.setBounds(siphonATPA[0].getBounds.x1 - 5, siphonATPA[0].getBounds.y1 - 5, siphonATPA[0].getBounds.x2 + 5, siphonATPA[0].getBounds.y2 + 5);

  result := true;
end;

function findSiphonParam(): boolean;
begin
  writeln('siphonBoundsBox is: ', siphonBoundsBox);
  smartImage.drawBox(siphonBoundsBox, true, clred);

  if findColorsTolerance(siphonTPA, siphonColor, siphonBoundsBox, siphonTol, colorSetting(2, siphonHue, siphonSat)) then
    exit(true);
end;

function getPixelShiftWildy(b: TBoxArray = [searchBox1]; time: integer): TIntegerArray;
var
  l, i: integer;
  bmpBefore, bmpAfter: TIntegerArray;
begin
  l := length(b);
  setLength(bmpBefore, l);
  setLength(bmpAfter, l);
  setLength(result, l);

  // get the initial pixels
  for i := 0 to (l - 1) do
    bmpBefore[i] := bitmapFromClient(b[i].x1, b[i].y1, b[i].x2, b[i].y2);

  wait(time);

  // get pixels after the wait
  for i := 0 to (l - 1) do
    bmpAfter[i] := bitmapFromClient(b[i].x1, b[i].y1, b[i].x2, b[i].y2);

  // calculate the pixels that changed
  for i := 0 to (l - 1) do
    result[i] := calculatePixelShift(bmpBefore[i], bmpAfter[i], intToBox(0, 0, (b[i].x2 - b[i].x1), (b[i].y2 - b[i].y1)));

  freeBitmaps(bmpBefore);
  freeBitmaps(bmpAfter);
end;

function xpChangeWildy(): boolean;
begin
  teleCheck;
  if weTeleported then
  begin
    writeln('attacked while looking for xp change, exitting true');
    exit(false);
  end;
  if xpChangedWildy then
    exit(true);
end;

procedure siphonWait({minWait: integer});
begin
  mouseOffClient(OFF_CLIENT_RIGHT);
  writeln('waiting for waitflag to go away @ siphonWait');
  minimap.waitFlag1;

  {
  waitTimer.start;
  repeat
    teleCheck();
    if weTeleported then
      break;
    wait(gaussRangeInt(100, 200));
  until (waitTimer.getTime > minWait);
  }

  repeat
    writeln('checking for change in exp while gathering memories');
    //prevXP := getXP;
    if not boolBeforeTimeWildy(, , 2400, 3600, @xpChangeWildy) then
      break;
  until false;
end;

procedure depositWait();
begin
  mouseOffClient(OFF_CLIENT_RIGHT);
  minimap.waitFlag1;

  repeat
    writeln('checking for change in exp while depositing memories');
    //prevXP := getXP;
    if not boolBeforeTimeWildy(, , 3000, 4200, @xpChangeWildy) then
      break;
  until false;
  {
  failtimer.start;
  repeat
    prevXP := getXP;
    waitTimer.start;
    repeat
      teleCheck();
      if weTeleported then
        break;
      wait(gaussRangeInt(50, 200));
    until ((prevXP <> getXP) or (waitTimer.getTime > gaussRangeInt(2450, 3650)));
  until ((prevXP = getXP) or (failtimer.getTime > 100000));
  if (failtimer.getTime > 100000) then
    scriptTerminator('took longer than 100k ms for depositWait to work properly wtf??');
  }
end;

//**********************************************************
// - checks if rift on mainscreen, if is return true else return false
//**********************************************************
function isRiftOnMS(): boolean;
begin
  loginProcedure;
  if not findColorsTolerance(riftTPA, 7920825, mainScreen.getBounds, 14, ColorSetting(2, 0.37, 1.22)) then
  begin
    writeln('rift not found on mainscreen');
    exit(false);
  end else
  begin
    if length(riftTPA) < minRiftLength then     //if tpa of rift isn't big enough then return false
    begin
      writeln('rift found, but area too small');
      exit(false);
    end;
    writeln('found the rift on mainscreen');
    exit(true);
  end;
end;

function offsetDivPoint(toRight: boolean): boolean;
begin
  //writeln('true or false: ', minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds));
  //writeln('to right is: ', toRight);
  //writeln('sadflkkdsajdsalfkjdsf p is: ', p);

  if not (PointInBox(p, minimap.getBounds)) then
  begin
    writeln('didn''t find an original p point to offset, exitting false');
    writeln('p is: ', p);
    writeln('minimap.getBounds is: ', minimap.getBounds);
    exit(false);
  end else
    writeln('found a p to [potentially] offset');

  if toRight then
  begin
    q.X := p.X + gaussRangeInt(20, 30);
    q.Y := p.Y + gaussRangeInt(1, 16);
  end else
  begin
    q.X := p.X - gaussRangeInt(20, 30);
    q.Y := p.Y - gaussRangeInt(1, 16);
  end;
  if (minimap1.isPointInside(q) or minimap2.isPointInside(q)) then
  begin
    writeln('succesfully offset p as q to t, exitting true');
    t := q;
    exit(true);
  end else
    writeln('failed to offset p as q, continuing');

  if toRight then
  begin
    r.X := p.X + gaussRangeInt(10, 25);
    r.Y := p.Y + gaussRangeInt(1, 16);
  end else
  begin
    r.X := p.X - gaussRangeInt(10, 25);
    r.Y := p.Y - gaussRangeInt(1, 16);
  end;
  if (minimap1.isPointInside(r) or minimap2.isPointInside(r)) then
  begin
    writeln('succesfully offset p as r to t, exitting true');
    t := r;
    exit(true);
  end else
    writeln('failed to offset p as r, continuing');

  if toRight then
  begin
    s.X := p.X + gaussRangeInt(5, 10);
    s.Y := p.Y + gaussRangeInt(1, 4);
  end else
  begin
    s.X := p.X - gaussRangeInt(5, 10);
    s.Y := p.Y - gaussRangeInt(1, 4);
  end;
  if (minimap1.isPointInside(s) or minimap2.isPointInside(s)) then
  begin
    writeln('succesfully offset p as s to t, exitting true');
    t := s;
    exit(true);
  end else
    writeln('failed to offset p as s, continuing');

  if not (minimap1.isPointInside(p) or minimap2.isPointInside(p)) then
  begin
    writeln('didn''t find original p point to offset, exitting false unless to right');
    if toRight then
      scriptTerminator('it was to right..what the fuck happened??');
    exit(false);
  end else
    writeln('no successful p offsets but p should be ok to set as t');

  t := p;
  result := true;
end;

procedure walkToRift(XforceWalk: boolean = false);
var
  riftTimer: TTimeMarker;
begin
  writeln('walking to rift');
  riftTimer.start;

  writeln('XforceWalk is: ', XforceWalk);
  if not XforceWalk then
    if isRiftOnMS then
    begin
      writeln('rift is on MS so we''re exitting walkToRift');
      exit;
    end;

  if not (minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds)) then
  begin
    writeln('did not find div symbol');
    repeat
      writeln('using cursedWispRift.blindWalk1 for up to 20 seconds here');
      cursedWispRift.blindWalk1([gaussRangeInt(127, 133), gaussRangeInt(181, 187)]);           //tries to walk to rift for 20 seconds
      teleCheck;
      if weTeleported then
        break;
    until ((minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds)) or (riftTimer.getTime > 25000));       // if not found rift terminate
    if riftTimer.getTime > 25000 then
      scriptTerminator('riftTimer is greater than 25000');

    minimap.waitFlag1;
  end;

  if weTeleported then
    exit;

  if (minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds)) then
  begin
    writeln('found div symbol, walking towards it');
    writeln('DSALKJASDLFKJSALKFJ p is: ', p);
    if not offsetDivPoint(true) then
      if not offsetDivPoint(false) then
        scriptTerminator('offsetDivPoints were both false, terminating');
    writeln('t is: ', t);
    moveMouse(t);
    fastClick(mouse_Left);
  end else
    scriptTerminator('why the fuck was div symbol not on minimap??');

  minimap.waitFlag1;
end;

//*************************************************************
//      add in a check to see if successfully clicked the wisp
//*************************************************************
function clickWisp(): boolean;
begin
  //prevXP := getXP;

  failtimer.start;
  for i := 0 to high(cursedWispATPA) do
  begin
    if failtimer.getTime > gaussRangeInt(1150, 2450) then
    begin
      writeln('took longer than ~2 seconds to find uptext? :(');
      exit(false);
    end;

    teleCheck;
    if weTeleported then
      exit(false);

    moveMouse(MiddleTPA(cursedWispATPA[i]));
    if not isMouseOverText(wispText, RandomRange(250, 650)) then
      continue; //if uptext is not found, it starts over again at the top of the loop

    //uptext was found so we're not using continue
    fastClick(mouse_Left);
    result := true;
    break; //exiting the loop
  end;
end;

function clickRift(debug: boolean; waitBefore: boolean = false): boolean;
begin
  //walkToRift;
  if weTeleported then
    exit(true);
  noGreen := 0;

  writeln('waitBefore is: ', waitBefore);
  if waitBefore then
    minimap.waitPlayerMoving;

  if (not isRiftOnMS) then
  begin
    writeln('rift was not found on MS so we''re exitting clickRift as false');
    exit(false);
  end;

  writeln('setting up riftATPA after finding rift on MS');
  riftATPA := riftTPA.toATPA(15);
  riftATPA.sortFromMidPoint(mainScreen.getCenterPoint);

  //if debug then
  begin
    smartImage.clear;
    smartImage.debugATPA(riftATPA);
  end;

  for i := 0 to high(riftATPA) do
  begin
    if not findColorsTolerance(riftTPA, 7920825, riftATPA[i].getBounds, 14, ColorSetting(2, 0.37, 1.22)) then
    begin
      writeln('no green in rift ATPA?');
      noGreen := noGreen + 1;
      writeln('no green is now: ', noGreen);
    end;
    if noGreen = noGreenMax then
    begin
      writeln('no green in rift ATPA ', noGreen, ' times? exitting false');
      exit(false);
    end;

    moveMouse(MiddleTPA(riftATPA[i]));
    if isMouseOverText(riftText) then
      break;
    if (i < high(riftATPA)) then
      continue;

    scriptTerminator('failed to click rift after each atpa? maybe change this w/ an exit(false)');
  end;

  if waitBefore then
    if RandomRange(1, 100) < 90 then
      wait(RandomRange(250, 405));
  fastClick(mouse_Right);

  if RandomRange(1, 100) < 90 then
    wait(gaussRangeInt(200, 400));

  if not chooseOption.optionsExist(riftoption) then
  begin
    writeln('options did NOT exist on first look, waiting 650-1250');
    wait(gaussRangeInt(650, 1250));
    if not chooseOption.select(riftOption) then
      exit(false) else
      exit(true);
  end else
    writeln('options DID exist on first look');

  if not chooseOption.select(riftOption) then
    exit(false);

  result := true;
end;

procedure teleToLodestone();
var
  options: TOptionArray;
  result, prevDest: boolean;
  filter: TTesseractFilter;
  randomTime: integer;
begin
  writeln('teleporting to wildy lodestone');
  failTimer.start;

  mouseCircle(minimap.button[MM_BUTTON_LODESTONE].center.x, minimap.button[MM_BUTTON_LODESTONE].center.y,
              minimap.button[MM_BUTTON_LODESTONE].radius, MOUSE_MOVE);
  fastClick(mouse_Right);

  chooseOption.isOpen(gaussRangeInt(3600, 4800));

  options := chooseOption.getOptions;
  result := length(Options) = 3;
  if not (result) then
    scriptTerminator('length of Options was not = to 3');

  if (not chooseOption.__select(['ilder', 'olcan'], mouse_left, false, 1.00, 1250, false, filter)) then
  //if (not chooseOption.select(['ilder', 'olcan'], gaussRangeInt(1250, 2450))) then
  begin
    chooseOption.select(['elepo'], gaussRangeInt(1250, 2450));

    failtimer2.start;
    repeat
      wait(RandomRange(300, 900));
    until ((lodestoneScreen.isOpen) or (failtimer2.getTime > 10000));
    if failtimer2.gettime > 10000 then
      scriptTerminator('took longer than 10000 for lodestoneScreen to open up?');

    lodestoneScreen.teleportTo(LOCATION_WILDERNESS);
  end;

  repeat
    wait(gaussRangeInt(300,900));
  until ((conversationBox.isOpen) or (failTimer.getTime > 45000));
  if failTimer.getTime > 45000 then
    scriptTerminator('could not get past tele chat warning dialog');

  if conversationBox.isOpen then
  begin
    conversationBox.continue(true, true);

    randomTime := gaussRangeInt(1250, 2450);
    failtimer2.start;
    repeat
      wait(gaussRangeInt(200, 400));
    until ((failtimer2.getTime > randomTime) or (conversationBox.findOption(['Yes'])));
    if failtimer2.getTime > randomTime then
      conversationBox.continue(true, true);
  end;

  repeat
    wait(gaussRangeInt(200, 400));
  until ((conversationBox.findOption(['Yes'])) or (failTimer.getTime > 45000));
  if failTimer.getTime > 45000 then
    scriptTerminator('where da yes at homie?? terminating');

  if (conversationBox.selectOption(1)) then
    wait(gaussRangeInt(18000, 27000));

  tabBackpack.open;
  mouseOffClient(OFF_CLIENT_RIGHT);
  wait(gaussrangeint(16500, 20000));
end;

function findNoWaitFlag(): boolean;
begin
  result := (not findDTM(flagDTM, x, y, mainScreen.getBounds));
end;

procedure waitFlagMS();
begin
  writeln('waiting until waitflag is no longer on MS');
  if not boolBeforeTime(150, 300, 15000, 20000, @findNoWaitFlag) then
    scriptTerminator('failed to not wait flag within 15-20 seconds') else
    writeln('no longer found wait flag on MS, done with waitFlagMS');
end;

procedure lodestoneToWispsBig();
begin
  mouse(point(678 + gaussRangeInt(1, 53), 16 + RandomRange(0, 5)), mouse_left);
  if randomrange(1, 100) < 90 then
    wait(gaussRangeInt(1250, 2450));

  makeMinimapBig;
  waitFlagMS;

  if randomrange(1, 100) < 10 then
    wait(gaussRangeInt(650, 2450));

  mouse(point(280 + Random(16), 16 + gaussRangeInt(0, 14)), mouse_left);

  if randomrange(1, 100) < 95 then
    wait(gaussRangeInt(50, 1850));

  makeMinimapSmall;
  minimap.waitPlayerMoving9;

  writeln('done, waiting 10 seconds b4 terminate');
  wait(10000);
end;

procedure lodeStoneToWisps();
begin
  writeln('walking to wisps from the lodestone');

  if not isVPS then
  begin
    lodeToWisp1.walkPath2([Point(gaussRangeInt(191, 219), gaussRangeInt(202, 223)), Point(gaussRangeInt(242, 260), gaussRangeInt(194, 212)), Point(gaussRangeInt(303, 314), gaussRangeInt(179, 199)), Point(gaussRangeInt(301, 311), gaussRangeInt(128, 143)), Point(gaussRangeInt(281, 291), gaussRangeInt(77, 99))]);
    lodeToWisp2.walkPath2([Point(gaussRangeInt(211, 228), gaussRangeInt(246, 263)), Point(gaussRangeInt(176, 191), gaussRangeInt(209, 218)), Point(gaussRangeInt(140, 150), gaussRangeInt(165, 173)), Point(gaussRangeInt(102, 120), gaussRangeInt(119, 135))]);
  end else
  begin
    lodeToWisp1.walkPath2([Point(gaussRangeInt(191, 219), gaussRangeInt(202, 223)), Point(gaussRangeInt(242, 260), gaussRangeInt(194, 212)), Point(gaussRangeInt(303, 314), gaussRangeInt(179, 199)), Point(gaussRangeInt(301, 311), gaussRangeInt(128, 143)), Point(gaussRangeInt(281, 291), gaussRangeInt(77, 99))]);
    lodeToWisp2.walkPath2([Point(gaussRangeInt(211, 228), gaussRangeInt(246, 263)), Point(gaussRangeInt(176, 191), gaussRangeInt(209, 218)), Point(gaussRangeInt(140, 150), gaussRangeInt(165, 173)), Point(gaussRangeInt(102, 120), gaussRangeInt(119, 135))]);
  end;

  if (not minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds)) then
  begin
    writeln('div symbol not found, blindwalking once');
    lodeToWisp2.blindWalk2([100+random(10), 105+random(10)]);
  end;

  writeln('done walking');
end;

procedure lodeStoneToWispsRAY();
begin
  writeln('walking to wisps from the lodestone');
  lodeToWisp1.walkPath2([Point(187, 228), Point(209, 228), Point(227, 216), Point(239, 198), Point(255, 186), Point(279, 180), Point(299, 154), Point(293, 122), Point(284, 90)]);
  lodeToWisp2.walkPath([Point(210, 241), Point(180, 219), Point(142, 227), Point(112, 227), Point(94, 201), Point(90, 163), Point(106, 135), Point(104, 89)]);
  if (not minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds)) then
  begin
    writeln('div symbol not found, blindwalking once');
    lodeToWisp2.blindWalk2([100+random(10), 105+random(10)]);
  end;
end;

procedure lodeStoneToWispsOLD();
begin
  writeln('walking to wisps from the lodestone');
  lodeToWisp1.walkPath2([Point(198, 208), Point(252, 180), Point(289, 128), Point(260, 70)]);
  lodeToWisp2.walkPath([Point(173, 218), Point(143, 164), Point(114, 103)]);
  if (not minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds)) then
  begin
    writeln('div symbol not found, blindwalking once');
    lodeToWisp2.blindWalk2([100+random(10), 105+random(10)]);
  end;
end;

procedure walkToVarrockWestBankfromGrandExchangeEntrance();
begin
  writeln('initiating blind walk to V West');
  mouse(point(719 + gaussRangeInt(1, 35), 151 + gaussRangeInt(1, 30)), mouse_left);
  minimap.waitFlag;
  gotovarrockwest.blindWalk([194, 163]);
end;

procedure walkToVarrockWestBankfromGrandExchangeEntranceRAY();
begin
  writeln('initiating blind walk to V West');
  gotovarrockwest.walkPath([Point(116, 82), Point(126, 90), Point(130, 104), Point(144, 110), Point(154, 112), Point(166, 120), Point(180, 124), Point(190, 134), Point(192, 152)]);
end;

procedure waitUntilNearBanks();
begin
  failtimer.start;
  repeat
    wait(RandomRange(200, 450));
    gotovarrockwest.blindWalk([194, 163]);
    //check if map is open - asdf
  until ((gotovarrockwest.getPlayerPos.Y > 135) or (failtimer.getTime > 15000));
  if failtimer.getTime > 15000 then
    scriptTerminator('took longer than 15000 for gotovarrockwest.getPlayerPos.Y to be greater than 135');
  if RandomRange(1, 100) < 15 then
    wait(gaussRangeInt(450, 850));
end;

procedure usePreset1();
begin
  writeln('using preset1');

  if justClick = true then
  begin
    bankScreen.clickButton(BANK_BUTTON_PRESET_1, false);
    if not boolBeforeTime(,, 3600, 4800, @closeDTMisNotOnScreen) then
      scriptTerminator('failed to use Preset 1');
  end else
  begin
    typesend('1', false);
    if not boolBeforeTime(,, 4850, 6050, @closeDTMisNotOnScreen ) then
    begin
      justClick := true;
      bankScreen.clickButton(BANK_BUTTON_PRESET_1, false);
      if not boolBeforeTime(,, 3600, 4800, @closeDTMisNotOnScreen) then
        scriptTerminator('failed to use Preset 1');
    end;
  end;

  writeln('used preset1');
end;

procedure usePreset2();
begin
  writeln('using preset2');

  if justClick = true then
  begin
    bankScreen.clickButton(BANK_BUTTON_PRESET_2, false);
    if not boolBeforeTime(,, 3600, 4800, @closeDTMisNotOnScreen) then
      scriptTerminator('failed to use Preset 2');
  end else
  begin
    typesend('2', false);
    if not boolBeforeTime(,, 4850, 6050, @closeDTMisNotOnScreen ) then
    begin
      justClick := true;
      bankScreen.clickButton(BANK_BUTTON_PRESET_2, false);
      if not boolBeforeTime(,, 3600, 4800, @closeDTMisNotOnScreen) then
        scriptTerminator('failed to use Preset 2');
    end;
  end;

  writeln('used preset2');
end;

procedure usePreset();
begin
  if firstLoad then
  begin
    usePreset1;
    firstLoad := false;
    exit;
  end;

  inc(presetCounter);
  if presetCounter = ChargesPerROW then
  begin
    presetCounter := 0;
    usePreset1;
  end else
    usePreset2;
end;

procedure openBank();
begin
  writeln('opening up the bank');
  if not getVarrockWestBankOnMS( , true, true, ) then
    if not getVarrockWestBankOnMS( , , true, true) then
      if not getVarrockWestBankOnMS( , , , true) then
        scriptTerminator('failed to open up varrock west bank three times, terminating');
  mouseOffClient(OFF_CLIENT_RIGHT);
end;

function shouldNotHealUpBoolFunc(): boolean;
begin
  result := (actionBar.getHPPercent > 99);
end;

procedure healUp();
begin
  writeln('healing up');
  tabBackpack.open;
  if tabBackpack.countDTM(monkfishDTM) > 0 then
  repeat
    tabBackpack.clickDTM(monkfishDTM, mouse_left, 'Eat', gaussRangeInt(1850, 3050), false)
  until actionbar.getHPPercent = 100 else
    scriptTerminator('looks like we''re out of monkfish, terminating script');
end;

procedure waitForBankToClose();
begin
  failtimer.start;
  writeln('waiting for bank to close');
  repeat
    wait(gaussRangeInt(200, 350));
  until ((failtimer.getTime > 15000) or (not FindDTM(closeDTM, x, y, mainscreen.getBounds)));
  if failtimer.getTime > 15000 then
    scriptTerminator('took more than 15 seconds to not find the closeDTM? terminating script');
  writeln('bank closed succesfully');
end;

procedure bankingTime(weShouldTeleport: boolean);
begin
  writeln('bankingTime! weShouldTeleport is set to: ', weShouldTeleport);

  if weShouldTeleport then
    teleAway;

  if randomrange(1, 100) < 90 then
  wait(gaussRangeInt(200, 350));

  if randomrange(1, 100) < 10 then
  wait(gaussRangeInt(2000, 3500));

  if weAreDeadEdge then
    scriptTerminator('we seem to have died and ended up at edge?? terminating');

  if youAreRay then
    walkToVarrockWestBankfromGrandExchangeEntranceRAY else
    walkToVarrockWestBankfromGrandExchangeEntrance;

  waitUntilNearBanks;
  openBank;
  usePreset;
  waitForBankToClose;

  teleToLodestone();

  if ChanceToBigWalk >= RandomRange(1, 100) then
  begin
    lodestoneToWispsBig;
  end else
    if youAreRay then
      lodeStoneToWispsRAY else
      lodeStoneToWisps;
  healUp; //perhaps should eat all instead
  openGameTab(TAB_EQUIPMENT, gaussRangeInt(9050, 13050));
  if not findDTM(rowDTM, x, y, tabBackpack.getBounds) then
    scriptTerminator('no rowDTM found, terminating');
end;

{
deprecated
}
procedure caseLodeToWisp();
begin
  case lodeToWisp2.getPlayerPos1(300, 0.4).y of
    -1: scriptTerminator('111lodeToWisp2 getplayerPos messed up fam, terminating.');
    0..75: lodeToWisp2.blindWalk1([100+random(10), 105+random(10)]);
    76..124:
    begin
      mouse(minimap.getDots(MM_DOT_NPC, minimap.getBounds).getMiddle, mouse_left);
      minimap.waitFlag1;
    end;
    125..175: lodeToWisp2.blindWalk1([100+random(10), 105+random(10)]);
    176..350: lodeToWisp2.blindWalk1([100+random(10), 105+random(10)]);
    351..1000: scriptTerminator('222lodeToWisp2 getplayerPos messed up fam, terminating.');
  end;
end;

procedure getDemMemories();
var
  hopCount, blindWalkCount: integer;
begin
  writeln('backpack was not full, let''s get dem memories');

  hopCount := 0;
  blindWalkCount := 0;

  writeln('starting to fill up inventory');
  repeat
    if weAreDeadEdge then
      scriptTerminator('we seem to have died and ended up at edge?? terminating');

    writeln('hopCount is: ', hopCount, ' blindWalkCount is: ', blindWalkCount);
    smartImage.clear;
    {
    writeln('checking for a 80% chance of exitting inventory filling loop if inv count is > 23');
    if tabBackpack.count > 23 then
      if randomrange(1, 100) < 80 then
      begin
        writeln('exitting getDemMemories loop early (80% chance if backpack count was found @ > 23)');
        break;
      end;
    }
    if weTeleported then
      break;

    while (not minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds)) do
    begin
      writeln('did not find div symbol on MM, doing failsafeWalk');
      {
      if blindWalkCount > 15 then
        scriptTerminator('we''ve tried to blindwalk over 15 times this inv?? terminating');
      inc(blindWalkCount);
      }
      failsafeWalk;
    end;

    if (not findWisp) then
    begin
      writeln('did not findWisp on MS');
      if blindWalkCount > 15 then
        scriptTerminator('we''ve tried to blindwalk over 15 times this inv?? terminating');
      inc(blindWalkCount);

      if not (length(minimap.getDots(MM_DOT_NPC, minimap.getBounds)) > 3) then
      begin
        inc(hopCount);
        if hopCount > 5 then
          scriptTerminator('we''ve hopped over 5 times this inv?? terminating');
        if not players[currentPlayer].switchToWorld then
          players[currentPlayer].switchToWorld(117);
        wait(gaussrangeint(650, 1250));
        loginProcedure;
      end;

      caseLodeToWisp;
      continue;
    end else
      if not clickWisp then
        continue else
        begin
          if boolBeforeTime(,,,, @redAroundMouse) then
            writeln('red around mouse found succesfully, continuing!') else
            begin
              writeln('red not found around mouse succesfully, not continuing!');
              continue;
            end;
        end;

    siphonWait({2000});

    if randomrange(1, 100) < chanceOfMinibreaksInbetweenSiphons then
      wildyBreakTime(true);
    if randomrange(1, 100) < chanceOfBreaksInbetweenSiphons then
      wildyBreakTime(false);

  //until tabBackpack.isFull;
    if ((mainloopTimer.getTime/60000) > minsToRunFor2) then
    begin
      writeln('breaking early due to mainloop timer being greater than minsToRunFor2');
      break;
    end;
  until conversationBox.isOpen;

  if randomrange(1, 100) < chanceOfBreaksBeforeDepositing then
    wildyBreakTime(false);
end;

procedure depositDemMemories();
begin
  writeln('let''s deposit dem memories');
  smartImage.clear;

  if weTeleported then
    exit;

  walkToRift;

  if weTeleported then
    exit;

  if not clickRift(false) then
    if not clickRift(false) then
    begin
      walkToRift(true);

      if weTeleported then
        exit;

      if not clickRift(false, true) then
        if not clickRift(false, true) then
        begin
          writeln('initiating the FOURTH!');
          wait(gaussRangeInt(2400, 4800));
          if not clickRift(false, true) then
            scriptTerminator('failed to click rift 4x');
        end;
    end;

  if weTeleported then
    exit;

  depositWait;

  if weAreDeadEdge then
    scriptTerminator('we seem to have died and ended up at edge?? terminating');

  if randomrange(1, 100) < chanceOfMinibreaksAfterDepositing then
    wildyBreakTime(true);
  if randomrange(1, 100) < chanceOfBreaksAfterDepositing then
    wildyBreakTime(false);

  if weAreDeadEdge then
    scriptTerminator('we seem to have died and ended up at edge?? terminating');

  if not findWisp then
    lodeToWisp2.walkPath1([point(105, 113)]);
end;

procedure collectEnergies(maxMinutes: integer);
begin
  energyTimer.start;
  repeat
    writeln('let''s get dem energies');
    gameTabs.openTab(TAB_EQUIPMENT);

    if weTeleported then
      break;

    getDemMemories;

    if weTeleported then
      break;

    if ((mainloopTimer.getTime/60000) > minsToRunFor2) then
      break;

    depositDemMemories;
  until ((energyTimer.getTime/60000) > maxMinutes);
end;

procedure cursedEnergiesScript(minsToRunFor: integer; leaveAfter: boolean);
begin
  mainloopTimer.start;
  minsToRunFor2 := minsToRunFor;
  writeln('RunFor2 is: ', minsToRunFor2);

  if not alreadySetup then
  begin
    alreadySetup := true;
    setup();
    resetFolder('C:\Simba\teleportPics');
  end;

  writeln('checking for div symbol @ startup, banking if not found');
  if not minimap.findSymbol(p, MM_SYMBOL_DIVINATION, minimap.getBounds) then
    bankingTime(true);

  repeat
    reloadTimer.start;
    reloadTime := (gaussRangeInt(60, 240) * 60000);
    repeat
      weTeleported := false;
      writeln('lets start getting energies');
      collectEnergies(gaussRangeInt(5, 45));
      if ((mainloopTimer.getTime/60000) < minsToRunFor) then
      begin
        teleAway;
        bankingTime(false);
      end;
    until ((reloadTimer.getTime > reloadTime) or ((mainloopTimer.getTime/60000) > minsToRunFor));
    if not ((mainloopTimer.getTime/60000) > minsToRunFor) then
      sixHourFix;
  until ((mainloopTimer.getTime/60000) > minsToRunFor);

  writeln('cursedEnergiesScript = done. leaveAfter is set to: ', leaveAfter);
  if leaveAfter then
    teleAway;
end;

procedure getNearestGuy(shouldDebug: boolean = false);
begin
  mmTPA := minimap.getDots(MM_DOT_PLAYER, minimap.getBounds, 55);
  msTPA := minimap.pointsToMainscreen(mmTPA, true);

  if length(msTPA) < 1 then
    exit;

  msATPA1 := msTPA.toATPA(1, 1);
  msATPA1.sortFromMidPoint(mainscreen.getCenterPoint);

  if shouldDebug then
    smartImage.debugATPA(msATPA1);

  moveMouse(point(msATPA1[0].getBounds.x1, msATPA1[0].getBounds.y1));
  wait(gaussRangeInt(50, 150));
  fastClick(mouse_right);

  for i := 0 to high(msATPA1) do
  begin
    writeln(msATPA1);
  end;
end;

function teleAway(): boolean; override;
var
  failTimer: TTimeMarker;
  p: TPoint;
begin
  if weTeleported then
    exit;

  weShouldTakeASecondPic := true;

  saveScreenshot('C:\Simba\teleportPics\'+ timeRunning() + '.png');

  if ((actionBar.getHPPercent < 100) and (actionBar.getAbilityCooldown(freedomSlot) = 100)) then
  begin      //freedom ability
    MoveMouse(actionBar.getSlotBox(freedomSlot).getmiddle);
    wait(gaussrangeint(200, 350));
    fastClick(mouse_Left);
    weShouldTakeASecondPic := true;
  end;

  if not findDTM(rowDTM, x, y, tabBackpack.getBounds) then
    if not gameTabs.openTab(TAB_EQUIPMENT) then
    begin
      wait(gaussRangeInt(200, 350));
      if not gameTabs.openTab(TAB_EQUIPMENT) then
        scriptTerminator('failed to open equipment tab');
    end;

  if not findDTM(rowDTM, x, y, tabBackpack.getBounds) then
  begin
    gameTabs.openTab(TAB_EQUIPMENT);
    wait(gaussRangeInt(200, 350));
    if not findDTM(rowDTM, x, y, tabBackpack.getBounds) then
    begin
      gameTabs.openTab(TAB_EQUIPMENT);
      wait(gaussRangeInt(650, 950));
      if not findDTM(rowDTM, x, y, tabBackpack.getBounds) then
        scriptTerminator('failed to find rowDTM in equipment tab, terminating');
    end;
  end;

  writeln('clicking rowDTM for the first time..');
  wait(gaussRangeInt(50, 250));
  moveMouse(point(x - 15, y - 15));
  mouse(point(x, y), mouse_right);
  if not boolBeforeTime(,, 400, 700, @geTextIsOpen) then
  begin
    writeln('failed to find geText, trying a second time');
    mouse(point(x, y), mouse_right);
    if not boolBeforeTime(,, 650 , 950, @geTextIsOpen) then
    begin
      writeln('failed to find geText, trying a third time');
      writeln('x is: ', x, ' y is: ', y);
      mouse(point(x, y), mouse_right);
      if not boolBeforeTime(,,,, @geTextIsOpen) then
        scriptTerminator('failed to get ge text after right clicking rowDTM a few times, terminating');
    end;
  end;

  writeln('succesfully found ge text after right clicking rowDTM');
  chooseOption.select(['rand', 'xhan'], 1250);

  if weShouldTakeASecondPic then
  begin
    getNearestGuy;
    saveScreenshot('C:\Simba\teleportPics\'+ timeRunning() + '.png');
  end;

  if RandomRange(1, 100) < 10 then
    wait(gaussRangeInt(150, 325));
  mouseOffClient(OFF_CLIENT_RIGHT);

  {
  moveMouse(actionBar.getSlotBox(wealthSlot).getmiddle);
  wait(gaussrangeint(200, 450));
  if randomrange(1, 100) < 50 then
    wait(gaussrangeint(200, 450));
  fastClick(mouse_Left);
  if randomrange(1, 100) < 50 then
    wait(gaussrangeint(200, 450));
  //typeSend('0', false);         //NO ring of wealth spam tele
  }
  failTimer.start;
  repeat
    wait(gaussRangeInt(100, 150));

    if ((minimap.findSymbol(p, MM_SYMBOL_TRANSPORTATION, minimap.getBounds)) and (failtimer.getTime > gaussRangeInt(650, 2450))) then
    begin
      writeln('bank found. teleported away');
      break;
    end;

  until (failTimer.getTime > 15000);
  if (failTimer.getTime > 15000) then
    scriptTerminator('took longer than 15000 to find rest spot');

  weTeleported := true;
  weShouldTeleport := false;
end;

function TPlayer.__handleLoginPopup(tries: integer; inLobby: boolean; out reachedMax: boolean): boolean; override;
var
  p: TPoint;
  i: integer;
  timeOut: TTimeMarker;
  popupMessage: string;
  errorMessage: TVariantArray;
  messages: array [0..17] of TVariantArray;
begin
  timeOut.start();

  repeat // Wait until the popup appears, or we hit the lobby/isLoggedIn
    case inLobby of
      true: if isLoggedIn() then exit(true);
      false: if (lobby.isOpen() or isLoggedIn()) then exit(true);
    end;

    //the if statement is all that's been added to the override.
    if findColor(x, y, 0, 96, 57, 96, 57) then
    begin
      mouse(Point(357 + gaussRangeInt(0, 80), 384 + gaussRangeInt(0, 4)), mouse_left);
      repeat
        wait(RandomRange(200, 300));
      until (not findColor(x, y, 0, 96, 57, 96, 57));
    end;

    popupMessage := __getPopupMessage();

    if (timeOut.getTime() > 60000) then
    begin
      print('Took too long to find login popup or login - respawning SMART');
      popupMessage := 'session has now ended'; // Trick it to reload
    end;

    if (timeOut.getTime() > 15000) then // If nothing after 15s, check we actually
    case inLobby of                     // clicked the Login button
      true: if lobby.findPlayButton(p) then exit(false);
      false: if __setInputBoxes() then exit(false);
    end;

    wait(random(500, 750));
  until (length(popupMessage) > 0);

  messages := [
    {Popup Text                         Wait time  MaxTries  Action}
    ['Unknown login popup',                   0,         2,  'Next_Player_F'],
    ['Invalid username or password',          0,         2,  'Next_Player_F'],
    ['Your account has been disabled',        0,         0,  'Next_Player_F'],
    ['Your ban will be lifted in',            0,         0,  'Next_Player_F'],
    ['Your account has been involved in',     0,         0,  'Next_Player_F'],
    ['Too many incorrect logins',             5 * 60000, 2,  'Next_Player_F'],
    ['Your account has not logged out',       15000,     5,  'Next_Player_T'],
    ['You need a member''s account',          0,         1,  'Set_Non-Member'],
    ['Player in member-only area',            0,         0,  'Set_Member'],
    ['Error connecting',                      20000,     4,  'Terminate'],
    ['Unable to connect',                     20000,     4,  'Terminate'],
    ['Runescape has been updated',            0,         0,  'Reload_Client'],
    ['Client token changed',                  0,         0,  'Reload_Client'],
    ['session has now ended',                 0,         0,  'Reload_Client'],
    ['Our systems are currently unavailable', 3 * 60000, 8,  'Reload_Client'],
    ['Login limit exceeded',                  20000,     8,  'Set_World'],
    ['You must have a total skill level of',  0,         0,  'Set_World'],
    ['Cannot connect to world',               10000,     0,  'Set_World']];

  for i := 0 to high(messages) do
    if (pos(messages[i][0], popupMessage) > 0) then
    begin
      errorMessage := messages[i];
      print('Login message: ' + errorMessage[0], TDebug.SUB);
      break();
    end;

  if length(errorMessage) < 1 then
  begin
    print('Unknown login popup message: ' + popupMessage, TDebug.WARNING);
    takeScreenshot('unknown_login_popup.png');
    print('PLEASE report this in the SRL-6 bugs section: https://villavu.com/forum/project.php?projectid=10', TDebug.HINT);
    errorMessage := ['Unknown login popup', 0, 3, 'Next_Player_F'];
  end;

  self.__respondToPopup(errorMessage, tries, reachedMax);
end;

function TPlayer.loginToLobby(): boolean; override;
var
  tries: integer = 1;
  reachedMaxTries: boolean;
begin
  print('TPlayer.loginToLobby(): ', TDebug.HEADER);
  __areDynamicInterfacesSet := false;

  if (not self.isActive) then
  begin
    print('TPlayer.loginToLobby(): Player ' + self.nickname + ' is not active...', TDebug.FOOTER);
    exit(false);
  end;

  if lobby.isOpen() then
  begin
    print('TPlayer.loginToLobby(): Player ' + self.nickname + ' is already in lobby.', TDebug.FOOTER);
    exit(true);
  end;

  if (not __setInputBoxes()) then
  begin
    print('TPlayer.loginToLobby(): Failed to find username and/or password box', TDebug.FOOTER);
    if findColor(x, y, 0, 96, 57, 96, 57) then
    begin
      mouse(Point(357 + gaussRangeInt(0, 80), 384 + gaussRangeInt(0, 4)), mouse_left);
      repeat
        wait(RandomRange(200, 300));
      until (not findColor(x, y, 0, 96, 57, 96, 57));
    end;
    exit(false);
  end;

  repeat
    if (isLoggedIn() or lobby.isOpen()) then
    begin
      result := true;
      break;
    end;

    print('Login Attempt ' + toStr(tries) + ': ' + capitalize(self.loginName) + ' (' + capitalize(self.displayName) + ')');

    print('Entering username...', TDebug.SUB);
    __enterLoginInfo(__boxUsername, self.loginName, true, true);
    wait(500 + random(200));

    print('Entering password...', TDebug.SUB);
    __enterLoginInfo(__boxPassword, self.password, false, true);
    wait(800 + random(200));

    result := self.__handleLoginPopup(inc(tries), false, reachedMaxTries);

    if reachedMaxTries then tries := 1; //'reachedMaxTries' is passed down from __respondToPopup()
  until result;

  if (not disableIPScreenshots) then takeScreenshot('IP_address.png');

  print('TPlayer.loginToLobby(): ' + toStr(result), TDebug.FOOTER);
end;


procedure test(); //lodeStoneToWisps
begin
  makeMinimapBig;
end;

begin
  setup;
  lodestoneToWispsBig;
  //cursedEnergiesScript(randomrange(29998, 29999), false);
end.
